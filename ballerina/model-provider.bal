// Copyright (c) 2025 WSO2 LLC (http://www.wso2.com).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/ai;
import ballerina/jballerina.java;
import ballerinax/openai.chat;

const DEFAULT_OPENAI_SERVICE_URL = "https://api.openai.com/v1";
const DEFAULT_MAX_TOKEN_COUNT = 512;
const DEFAULT_TEMPERATURE = 0.7d;

# ModelProvider is a client class that provides an interface for interacting with OpenAI Large Language Models.
public isolated distinct client class ModelProvider {
    *ai:ModelProvider;
    private final chat:Client llmClient;
    private final OPEN_AI_MODEL_NAMES modelType;
    private final decimal temperature;
    private final int maxTokens;

    # Initializes the OpenAI model with the given connection configuration and model configuration.
    #
    # + apiKey - The OpenAI API key
    # + modelType - The OpenAI model name
    # + serviceUrl - The base URL of OpenAI API endpoint
    # + maxTokens - The upper limit for the number of tokens in the response generated by the model
    # + temperature - The temperature for controlling randomness in the model's output  
    # + connectionConfig - Additional HTTP connection configuration
    # + return - `()` on successful initialization; otherwise, returns an `ai:Error`
    public isolated function init(@display {label: "API Key"} string apiKey,
            @display {label: "Model Type"} OPEN_AI_MODEL_NAMES modelType,
            @display {label: "Service URL"} string serviceUrl = DEFAULT_OPENAI_SERVICE_URL,
            @display {label: "Maximum Tokens"} int maxTokens = DEFAULT_MAX_TOKEN_COUNT,
            @display {label: "Temperature"} decimal temperature = DEFAULT_TEMPERATURE,
            @display {label: "Connection Configuration"} *ConnectionConfig connectionConfig) returns ai:Error? {
        chat:ClientHttp1Settings?|error http1Settings = connectionConfig?.http1Settings.cloneWithType();
        if http1Settings is error {
            return error ai:Error("Failed to clone http1Settings", http1Settings);
        }
        chat:ConnectionConfig openAiConfig = {
            auth: {
                token: apiKey
            },
            httpVersion: connectionConfig.httpVersion,
            http1Settings: http1Settings,
            http2Settings: connectionConfig.http2Settings,
            timeout: connectionConfig.timeout,
            forwarded: connectionConfig.forwarded,
            poolConfig: connectionConfig.poolConfig,
            cache: connectionConfig.cache,
            compression: connectionConfig.compression,
            circuitBreaker: connectionConfig.circuitBreaker,
            retryConfig: connectionConfig.retryConfig,
            responseLimits: connectionConfig.responseLimits,
            secureSocket: connectionConfig.secureSocket,
            proxy: connectionConfig.proxy,
            validation: connectionConfig.validation
        };
        chat:Client|error llmClient = new (openAiConfig, serviceUrl);
        if llmClient is error {
            return error ai:Error("Failed to initialize OpenAiProvider", llmClient);
        }
        self.llmClient = llmClient;
        self.modelType = modelType;
        self.temperature = temperature;
        self.maxTokens = maxTokens;
    }

    # Sends a chat request to the OpenAI model with the given messages and tools.
    #
    # + messages - List of chat messages or a single user message
    # + tools - Tool definitions to be used for the tool call
    # + stop - Stop sequence to stop the completion
    # + return - Function to be called, chat response or an error in-case of failures
    isolated remote function chat(ai:ChatMessage[]|ai:ChatUserMessage messages, ai:ChatCompletionFunctions[] tools,
            string? stop = ()) returns ai:ChatAssistantMessage|ai:Error {
        chat:CreateChatCompletionRequest request = {
            max_completion_tokens: self.maxTokens,
            temperature: self.temperature,
            stop,
            model: self.modelType,
            messages: check self.prepareCompletionRequestMessages(messages, tools)
        };
        boolean supportsToolCalls = isToolCallSupported(self.modelType);
        if supportsToolCalls && tools.length() > 0 {
            request.functions = tools;
        }

        chat:CreateChatCompletionResponse|error response = self.llmClient->/chat/completions.post(request);
        if response is error {
            return error ai:LlmConnectionError("Error while connecting to the model", response);
        }
        chat:CreateChatCompletionResponse_choices[] choices = response.choices;
        if choices.length() == 0 {
            return error ai:LlmInvalidResponseError("Empty response from the model when using function call API");
        }

        return self.convertResponseToAssistantMessage(choices[0].message);
    }

    # Sends a chat request to the model and generates a value that belongs to the type
    # corresponding to the type descriptor argument.
    # 
    # + prompt - The prompt to use in the chat messages
    # + td - Type descriptor specifying the expected return type format
    # + return - Generates a value that belongs to the type, or an error if generation fails
    isolated remote function generate(ai:Prompt prompt, typedesc<anydata> td = <>) returns td|ai:Error = @java:Method {
        'class: "io.ballerina.lib.ai.openai.Generator"
    } external;

    private isolated function prepareCompletionRequestMessages(ai:ChatMessage[]|ai:ChatUserMessage messages,
            ai:ChatCompletionFunctions[] tools) returns chat:ChatCompletionRequestMessage[]|ai:Error {
        chat:ChatCompletionRequestMessage[] chatCompletionRequestMessages = [];
        if messages is ai:ChatUserMessage {
            chatCompletionRequestMessages.push({
                role: ai:USER,
                content: check getChatMessageStringContent(messages.content),
                name: messages.name
            });
            return chatCompletionRequestMessages;
        }
        boolean supportsToolCalls = isToolCallSupported(self.modelType);
        foreach ai:ChatMessage message in messages {
            if message is ai:ChatSystemMessage && !supportsToolCalls {
                string reactPrompt = constructReActPrompt(extractToolInfo(tools),
                        check getChatMessageStringContent(message.content));
                chatCompletionRequestMessages.push({role: ai:SYSTEM, content: reactPrompt});
            } else if message is ai:ChatAssistantMessage {
                chat:ChatCompletionRequestAssistantMessage assistantMessage = self.buildRequestAssistantMessage(message);
                chatCompletionRequestMessages.push(assistantMessage);
            } else if message is ai:ChatUserMessage {
                chatCompletionRequestMessages.push({
                    role: ai:USER,
                    content: check getChatMessageStringContent(message.content),
                    name: message.name
                });
            } else if message is ai:ChatSystemMessage {
                chatCompletionRequestMessages.push({
                    role: ai:SYSTEM,
                    content: check getChatMessageStringContent(message.content),
                    name: message.name
                });
            } else if message is ai:ChatFunctionMessage|ai:ChatAssistantMessage {
                chatCompletionRequestMessages.push(message);
            }
        }
        return chatCompletionRequestMessages;
    }

    private isolated function buildRequestAssistantMessage(ai:ChatAssistantMessage message)
    returns chat:ChatCompletionRequestAssistantMessage {
        chat:ChatCompletionRequestAssistantMessage assistantMessage = {role: ai:ASSISTANT};
        boolean supportsToolCalls = isToolCallSupported(self.modelType);
        ai:FunctionCall[]? toolCalls = message.toolCalls;
        if supportsToolCalls && toolCalls is ai:FunctionCall[] {
            ai:FunctionCall functionCall = toolCalls[0];
            assistantMessage.function_call = {
                name: functionCall.name,
                arguments: functionCall.arguments.toJsonString()
            };
        } else if !supportsToolCalls && toolCalls is ai:FunctionCall[] {
            assistantMessage.content = formatFunctionCallToJsonWithFences(toolCalls[0]);
        }
        string? content = message?.content;
        if supportsToolCalls && content is string {
            assistantMessage.content = content;
        } else if !supportsToolCalls && content is string {
            assistantMessage.content = formatFinalAnswerToJsonWithFences(content);
        }
        return assistantMessage;
    }

    private isolated function convertResponseToAssistantMessage(chat:ChatCompletionResponseMessage? message)
    returns ai:ChatAssistantMessage|ai:LlmError {
        do {
            boolean hasToolCallResponse = isToolCallSupported(self.modelType);
            ai:ChatAssistantMessage chatAssistantMessage = {role: ai:ASSISTANT};
            if hasToolCallResponse {
                chatAssistantMessage.content = message?.content;
                chat:ChatCompletionRequestAssistantMessage_function_call? functionCall = message?.function_call;
                if functionCall is chat:ChatCompletionRequestAssistantMessage_function_call {
                    json arguments = check functionCall.arguments.fromJsonString();
                    chatAssistantMessage.toolCalls = [
                        {
                            name: functionCall.name,
                            arguments: check arguments.cloneWithType()
                        }
                    ];
                }
                return chatAssistantMessage;
            }
            ai:LlmToolResponse|LlmChatResponse parsedReActResponse = check parseReActLlmResponse(message?.content);
            if parsedReActResponse is ai:LlmToolResponse {
                chatAssistantMessage.toolCalls = [parsedReActResponse];
                return chatAssistantMessage;
            }
            // Set the "Final Answer" action's input to the chat assistant message content
            chatAssistantMessage.content = parsedReActResponse.content;
            return chatAssistantMessage;
        } on fail error e {
            return error("Invalid or malformed arguments received in function call response.", e);
        }
    }
}

isolated function getChatMessageStringContent(ai:Prompt|string prompt) returns string|ai:Error {
    if prompt is string {
        return prompt;
    }
    string[] & readonly strings = prompt.strings;
    anydata[] insertions = prompt.insertions;
    string promptStr = strings[0];
    foreach int i in 0 ..< insertions.length() {
        string str = strings[i + 1];
        anydata insertion = insertions[i];

        if insertion is ai:TextDocument|ai:TextChunk {
            promptStr += insertion.content + " " + str;
            continue;
        }

        if insertion is ai:TextDocument[] {
            foreach ai:TextDocument doc in insertion {
                promptStr += doc.content + " ";
            }
            promptStr += str;
            continue;
        }

        if insertion is ai:TextChunk[] {
            foreach ai:TextChunk doc in insertion {
                promptStr += doc.content + " ";
            }
            promptStr += str;
            continue;
        }

        if insertion is ai:Document {
            return error ai:Error("Only Text Documents are currently supported.");
        }

        promptStr += insertion.toString() + str;
    }
    return promptStr.trim();
}
